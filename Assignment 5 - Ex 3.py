#importing libraries
import numpy as np
import matplotlib.pyplot as plt

#defining the variables which will be used in this program
x1, x2 = 0, 17
alpha, gamma, ro, sig = 1, 2, 0.5, 0.5
n = 10

#defining the first function, this will take values x1 and x2 and sort which
#value represents the best point and which is the worst point.
def order_points(x1, x2):
    #an if/else statement finds out which value is the lowest and will assign
    #that value to x_best and the larger to x_worst. This would be adapted to
    #work the other way around if looking for a maximum.
    if f(x1) <= f(x2):
        x_best = x1
        x_worst = x2
    else:
        x_best = x2
        x_worst = x1
   #the best and worst points are then output as a tuple in this order 
   #specifically
    return(x_best, x_worst)

#another function defined. This function is the main nelder mead step and takes
#values x1 and x2 and assigns them different roles and calulates a futher set
#of variables depending on which conditions are met    
def nelder_mead_step(x1, x2):
      
    #here order_points function is called to find out which point is best and 
    #which is worst. The best point becomes the centre point. A value reflected
    #around this centre point (of the worst point) in the x axis is then calculated
    x_best, x_worst = order_points(x1, x2)
    x_cent = x_best
    x_refl = x_cent + alpha*(x_cent - x_worst)
    
    #this if statement tests if when the reflected point is placed into our
    #function (defined below) is it a better (lower) value than the current
    #best point? If it is then an expanded point is calculated (a reflected
    #point plus a little extra) and this is then also tested to see if it is
    #the best so far. Depending on if it is or isnt there is a reshuffling of
    #variables to account for the new information.
    if f(x_refl) < f(x_best):
        x_exp = x_cent + gamma*(x_refl - x_cent)
        if f(x_exp) < f(x_refl):
            x_worst = x_exp
        else:
            x_worst = x_refl
    #if the above statement isnt true this else statement is triggered. A 
    #contracted point is calculated, which is similar to the reflected but
    #acts in the opposite sense.         
    else:
        x_contr = x_cent + ro*(x_worst - x_cent)
        #depending on the results of the inequalities below a series of
        #variable reshuffles is carried out
        if f(x_contr) < f(x_worst):
            x_worst = x_contr
        else:
            x_worst = x_best + sig*(x_worst - x_best)
    #the best and worst (lowst and highest outputs of the function) are then
    #output
    return(x_best, x_worst)

#this is our function, it is in a function as it needs to be easily called
#throughout the program rather than having to type out the function over and 
#over
def f(x):
    return((x-7)**2 + 20)

#the real beginning of the program, this is where an array of 1000 evenly spaced
#values between 0.0 and 15.0 are generated
x = np.linspace(0, 15, 1000)    
#a plot of the above array and the results of the function of the above array
#is to be plotted with a dashed line and in black
plt.plot(x, f(x), '--', linewidth=1, color='black')

#two arrays for x1 and x2 values to be deposited into after the array x is sent
#to a function initially filld with zeroes
x1_array = np.zeros(n)
x2_array = np.zeros(n)

#iterating n times over a range of values
for i in range (n):
    #assigning x1 and x2 to the new values output by the nelder mead step
    #if this isn't done the x1 and x2 values will be static and the program
    #won't do anything useful
    x1, x2 = nelder_mead_step(x1, x2)
    x1_array[0] = 0
    #setting every ith term to the result generated by the nelder mead function
    x1_array[i], x2_array[i] = nelder_mead_step(x1, x2)
#plotting the best data points from the program to be plotted as dots joined by
#a line, to visualise the descent.
plt.plot(x1_array, f(x1_array), '-o', color='red', linewidth=1)
plt.xlabel('x values')
plt.ylabel('f(x) values')
plt.title('Plot of x against f(x) and the best points from the Nelder-Mead\nalgorithm to find the minimum point')
plt.legend(['f(x)', 'Nelder-Mead best points plot'])
#showing where the plot should be output and then printing the 10th result 
#(as an array counts from 0 we use [9] for the 10th value) from the array.
plt.show()
print("Minimizing value of x (by 10 iterations of 1D Nelder-Mead): ", x1_array[9])



    
